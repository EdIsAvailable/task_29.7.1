Задание 29.7.1 (HW-04) к модулю 29. 

Проектирование многопоточных структур данных Fine-Grained Queue.

Описание

Данный проект реализует потокобезопасный односвязный список с использованием мелкогранулярной блокировки (fine-grained locking). Такой подход позволяет нескольким потокам одновременно работать с разными участками списка, что существенно повышает производительность в многопоточных средах по сравнению с использованием грубой блокировки всей структуры данных.


Особенности реализации

Мелкогранулярная блокировка — каждый узел списка защищен собственным мьютексом
Hand-over-hand locking — алгоритм последовательной блокировки узлов для безопасного перемещения по списку
Безопасная вставка — метод insertIntoMiddle позволяет безопасно вставлять элементы в середину или конец списка
Созданы конструкторы и деструкторы для правильного управления памятью
Реализован метод initialize для создания первого элемента списка
Создан метод printList для отладки и демонстрации работы.
В методе insertIntoMiddle используется последовательная блокировка узлов.
Обрабатываются все граничные случаи (вставка после первого элемента, вставка в конец списка)
Реализована защита от состояний гонки
Предотвращены возможные взаимоблокировки путем правильного порядка захватов и освобождений мьютексов
Документация — весь код содержит комментарии в формате Doxygen. (Не проверено, опыта почти нет)
Учтены замечания ментора к предыдущему заданию, но все файлы и папка build всё равно подтянулась на github, zaraza)))


Детали реализации


Создание нового узла:

Создаем узел с указанным значением и инициализируем его мьютекс


Блокировка и поиск позиции:

Сначала блокируем мьютекс всей очереди для доступа к голове списка
Далее реализуем технику "hand-over-hand locking" - последовательной блокировки узлов
При переходе к следующему узлу сначала блокируем его, потом разблокируем предыдущий


Обработка граничных случаев:

Если pos <= 0, вставляем после первого элемента
Если pos больше длины списка, вставляем в конец благодаря условию в цикле


Безопасность и предотвращение взаимоблокировок:

Каждый раз блокируем максимум два соседних узла
Разблокируем мьютекс очереди сразу после захвата первого узла
Всегда поддерживаем правильный порядок блокировок - от начала списка к концу


Освобождение ресурсов:

Перед выходом из функции освобождаем все ранее захваченные блокировки.